/*********************************1087************************************
题目描述：
输入n个整数,依次输出每个数的约数的个数
输入：
输入的第一行为N，即数组的个数(N<=1000)
接下来的1行包括N个整数，其中每个数的范围为(1<=Num<=1000000000)
当N=0时输入结束。
输出：
可能有多组输入数据，对于每组输入数据，
输出N行，其中每一行对应上面的一个数的约数的个数。
样例输入：
5
1 3 4 6 12
样例输出：
1
2
3
4
6
**************************************************************************/

#include <stdio.h>

int num[1001];
int result[1001];
int prime[10001];
int hash[31624];
int cnt;

void init(){
	int i, j;
	for(i=0; i<31624; i++)
		hash[i] = 0;
	cnt = 0;
	for(i=2; i<31624; i++){
		if(hash[i] == 1)
			continue;
		prime[cnt++] = i;
		for(j=i*i; j<31624; j+=i)
			hash[j] = 1;
	}
}

int main(void){
	init();
	int N;
	int i, j, result, count;
	while(scanf("%d", &N) != EOF){
		if(N == 0)
			break;
		for(i=0; i<N; i++)
			scanf("%d", num+i);
		for(i=0; i<N; i++){
			result = 1;
			for(j=0; j<cnt; j++){
				count = 0;
				while(num[i] % prime[j] == 0){
					count++;
					num[i] /= prime[j];
				}
				result *= (count+1);
				if(num[i] == 1)
					break;
			}
			if(num[i] != 1)
				result *= 2;
			printf("%d\n", result);
		}
	}
	return 0;
}

/***********************************************************
有三点需要说明一下：
1.经测试：
开两个100000大小的数组不会造成runtime error
在init函数中有三个循环，当循环次数过大时，例如三个循环次数
上限均为50000时（此时依然有两个100000的数组）就会报错，但是
如果有一个循环是31472，两个50000时没问题；有一个100000，两个
31472时也没问题。
以上测试作为经验可供以后参考

2.提交出现WA的原因在于漏解，这种分解质因数的算法要判断到sqrt(x)
才能结束，sqrt(1000000000) ~= 31471.77，因此至少应该检查到
31472，之前的提交中只检查到10000显然不够

3.另外临界情况在有些案例中不一定是极限情况。例如该题中极限情况
是求1000000000的约束，对其进行分解后可以在素数范围10000以内
完成，即不存在大于10000的素因数，所以在前面的提交中并没有暴露
出问题。而如果测试例如大于10000的素数的平方，则很容易暴露问题
************************************************************/