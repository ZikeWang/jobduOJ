/*********************************1449************************************
题目描述：
有N个比赛队（1<=N<=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，
裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每
个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2
之前。现在请你编程序确定排名。
输入：
输入有若干组，每组中的第一行为二个数N（1<=N<=500），M；其中N表示队伍的个数，
M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即
P1队赢了P2队。
输出：
给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。
其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；
输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。
样例输入：
4 3
1 2
2 3
4 3
样例输出：
1 2 4 3
**************************************************************************/

#include <stdio.h>
#include <vector>
#include <queue>

using namespace std;

vector<int> edge[501];
queue<int> Q;
int inDegree[501];
int tmp[501];

int main(){
    int n, m, a, b;
    int i, j, k, cnt, tmp_cnt, swap, temp, x;
    while(scanf("%d %d", &n, &m) != EOF){
        for(i=0; i<=500; i++){
            edge[i].clear();
            inDegree[i] = 0;
            tmp[i] = 0;
        }

        while(Q.empty() == 0)
            Q.pop();

        while(m-- != 0){
            scanf("%d %d", &a, &b);
            edge[a].push_back(b);
            inDegree[b]++;
        }

        tmp_cnt = 0;
        for(i=1; i<=n; i++)
            if(inDegree[i] == 0)
                tmp[tmp_cnt++] = i;
        for(i=0; i<tmp_cnt; i++)
            for(j=0; j<tmp_cnt-1-i; j++)
                if(tmp[j] < tmp[j+1]){
                    swap = tmp[j];
                    tmp[j] = tmp[j+1];
                    tmp[j+1] = swap;
                }
        while(tmp_cnt){
            temp = tmp[tmp_cnt-1];
            Q.push(temp);
            tmp_cnt--;
            for(k=0; k<edge[temp].size(); k++){
                inDegree[edge[temp][k]]--;
                if(inDegree[edge[temp][k]] == 0)
                    tmp[tmp_cnt++] = edge[temp][k];
                for(i=0; i<tmp_cnt; i++)
                    for(j=0; j<tmp_cnt-1-i; j++)
                        if(tmp[j] < tmp[j+1]){
                            swap = tmp[j];
                            tmp[j] = tmp[j+1];
                            tmp[j+1] = swap;
                        }
            }
        }

        cnt = 0;
        while(Q.empty() == 0){
            x = Q.front();
            if(cnt < n-1)
                printf("%d ", x);
            else
                printf("%d\n", x);
            Q.pop();
            cnt++;
        }
    }
    return 0;
}

/**********************************************************************
有两点需要注意：
1.一开始的思路有点复杂，不需要考虑说当两个结点都指向同一个结点才把他们
都加入到队列中。只需要每次将所有入度为0的结点加入后排序然后输出最小序号，
然后再把该最小序号所在的边去掉，重新计算入度，再把为0的加入后排序，再输
出最小的，以此类推，直到遍历完所有结点。这样做是因为在排序数组中，没有
入度不为0的结点，因此数组中的结点要么指向同一结点，要么指向不同结点，不
管是否指向同一节点，每次输出最小的都是满足要求的（其实我认为题目的设计
是有问题的，例如8，7（1，2）（2，3）（4，7）（7，3）（3，8）（5，6）
（6，8）的排序就不严谨存在问题，但由于题目说保证给出的案例有一个正确的
排序，因此该算法不用去追究严格正确的顺序，这个案例本身也无法给出一个严格
正确的顺序）
2.使用数组来替代优先队列，每次输出最小的元素，之前是按从小到大排序，每次
输出第一个，然后用最后一个来填第一个的坑，一直WA，可以换一个思路，从大
到小进行排序，每次输出最后一个然后数组元素的个数减1即可，避免了填坑问题
***********************************************************************/