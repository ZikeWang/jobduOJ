/********************************1007*************************************
题目描述：
按要求，给国家进行排名。
输入：
有多组数据。
第一行给出国家数N，要求排名的国家数M，国家号从0到N-1。
第二行开始的N行给定国家或地区的奥运金牌数，奖牌数，人口数（百万）。
接下来一行给出M个国家号。
输出：
排序有4种方式: 金牌总数 奖牌总数 金牌人口比例 奖牌人口比例 
对每个国家给出最佳排名排名方式 和 最终排名
格式为: 排名:排名方式
如果有相同的最终排名，则输出排名方式最小的那种排名，对于排名方式，
金牌总数 < 奖牌总数 < 金牌人口比例 < 奖牌人口比例 
如果有并列排名的情况，即如果出现金牌总数为 100,90,90,80.则排名为1,2,2,4.
每组数据后加一个空行。
样例输入：
4 4
4 8 1
6 6 2
4 8 2
2 12 4
0 1 2 3
4 2
8 10 1
8 11 2
8 12 3
8 13 4
0 3
样例输出：
1:3
1:1
2:1
1:2

1:1
1:1

**************************************************************************/

#include <stdio.h>
#include <malloc.h>

typedef struct Info{
	double gold;
	double medal;
	double num;
	double gper;
	double mper;
	int flag;
}country, *pcountry;

int main() {
	int n, m;
	int i, j, no, min, way;
	int s[4]; 
	while(scanf("%d %d", &n, &m) != EOF){
		pcountry head = (pcountry)malloc(sizeof(country)*n);
		pcountry p = head;
		for(i=0; i<n; i++)
			p[i].flag = 0;
		p = head;
		for(i=0; i<n; i++){
			scanf("%lf %lf %lf", &(p->gold), &(p->medal), &(p->num));
			p->gper = p->gold / p->num;
			p->mper = p->medal / p->num;
			p++;
		}
		p = head;
		for(i=0; i<m; i++){
			scanf("%d", &no);
			p[no].flag = 1;
		}
		//p = head;
		for(i=0; i<n; i++){
			if(p[i].flag == 1){
				s[0] = 1;
				for(j=0; j<n; j++)
					if(p[j].flag==1 && p[j].gold>p[i].gold)
						s[0]++;
				
				s[1] = 1;
				for(j=0; j<n; j++)
					if(p[j].flag==1 && p[j].medal>p[i].medal)
						s[1]++;
						
				s[2] = 1;
				for(j=0; j<n; j++)
					if(p[j].flag==1 && p[j].gper>p[i].gper)
						s[2]++;
						
				s[3] = 1;
				for(j=0; j<n; j++)
					if(p[j].flag==1 && p[j].mper>p[i].mper)
						s[3]++;
				
				min = n+1;
				for(j=0; j<4; j++){
					if(s[j] < min){
						min = s[j];
						way = j + 1;
					}
				}
				printf("%d:%d\n", min, way);
			}
		}
		printf("\n");
		free(head);
	}
	
	return 0;
}

/***************************************************************************
这道题实际上并不难，但是在方法的选择和一些细节上有值得注意的地方
1.暴露出的最大的问题在于审题和理解题目意思。题目说的是输出格式是名次：方法，
但是在核对测试用例时始终当作方法：名次的输出格式在检查，所以一直觉得测试用例
不对，从而在这个问题上浪费了太多时间
2.由于未指明n的范围，因此如果盲目地用一个数组或结构体数组来定义的话很危险，
所以本题采用了malloc函数来动态地分配存储空间，最后Line 108释放空间这一步经
测试，如果不要这一行也可以通过OJ的测试，但最好加上
3.用malloc函数后返回的是一个指向结构体数组的指针head，这是访问某一个结构体
的某一个域x，既可以用下标方式head[i].x，也可以用指针方式(p+i)->x
4.这道题提交出现WA的原因在于变量的类型，之前用的float，全部改成double就行了，
可能是精度方面的原因。在以后的解题中，碰到有除法运算的，一定要考虑是否需要
使用浮点类型，另外要考虑是否尽量使用更高精度的double。其次，在修改某个变量的
类型后，一定在再次检查是否相应的地方例如格式转换符等需要修改
5.Line 74多余因为Line 69以后均采用下标方式访问结构体数组，并没有修改p的值
6.本题虽然涉及到排序问题，但根本上来说是找最大最小值这类的极值问题，另外常规
的排序算法会交换各元素的位置，显然本题并不希望对位置做交换否则后面在筛选极值
时会越来越麻烦，另外，本体要求只对选中的m个元素查找极值，因此综合这些因素，
选择用循环比较的方法更加合适。所以有时候涉及到排序的问题，传统的排序方法，例
如冒泡快排等不一定就合适，要具体分析，如有时不一定需要进行排序还只需筛选即可
7.题目的细节问题。如只对m个元素排名，最后多打一个空行，选用浮点且float不合适
时要用double
****************************************************************************/