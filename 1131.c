/*********************************1131************************************
题目描述：
N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交
换位置就能排成合唱队形。
合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的
身高分别为T1, T2, …, TK，
则他们的身高满足T1 < T2 < … < Ti , Ti > Ti+1 > … > TK (1 <= i <= K)。
你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下
的同学排成合唱队形。
输入：
输入的第一行是一个整数N（2 <= N <= 100），表示同学的总数。
第一行有n个整数，用空格分隔，第i个整数Ti（130 <= Ti <= 230）是第i位同学的
身高（厘米）。
输出：
可能包括多组测试数据，对于每组数据，
输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。
样例输入：
8
186 186 150 200 160 130 197 220
样例输出：
4
**************************************************************************/

#include <stdio.h>

int t[102];
int d[102];
int d1[102];
int d2[102];

int max(int a, int b){
	return a>=b ? a : b;
}

int main(){
	int n;
	int i, j, tmax1, tmax2, ans;
	while(scanf("%d", &n) != EOF){
		ans = 0;
		for(i=0; i<102; i++){
			d1[i] = 0;
			d2[i] = 0;
			d[i] = 0;
			t[i] = 0;
		}

		for(i=0; i<n; i++)
			scanf("%d", t+i);

		for(i=0; i<n; i++){
			tmax1 = 1;
			for(j=0; j<i; j++){
				if(t[j] < t[i])
					tmax1 = max(tmax1, d1[j]+1);
				//else
					//tmax= max(tmax, d[j]);
			}
			d1[i] = tmax1;
		}

		for(i=n-1; i>=0; i--){
			tmax2 = 1;
			for(j=n-1; j>i; j--){
				if(t[j] < t[i])
					tmax2 = max(tmax2, d2[j]+1);
			}
			d2[i] = tmax2;
		}

		for(i=0; i<n; i++)
			d[i] = d1[i] + d2[i];

		for(i=0; i<n; i++){
			ans = max(ans, d[i]);
		}
		printf("%d\n", n-ans+1);
	}
	return 0;
}

/*************************************************************************
这道题有三个问题需要注意：
1.对最长递增（或不增）子序列的算法理解问题。数组d[i]保存的是以第i个元素为
结尾的子序列的最大长度，也即第i个元素是子序列的一部分并且还是该子序列的最
后一个元素；代码Line 55、56的错误就在于把d[i]的意义理解成了在第i个元素前的
所有元素中找一个最长子序列，第i个元素可以不在其中，而d[i]保存的是这样一个
子序列的长度。
2.本题的算法中，以第i个元素为界分别求以其为最后的一个元素时的最长递增子序列
和以其为第一个元素的最长递减子序列。那么最后将两部分的长度相加时，把第i个元
素计算了两遍，所以最后要减1；另外题目要输出的是出列的元素个数，而不是保留的
最长子序列的元素个数，因此还要用总人数相减。
3.提交时要注意把不必要的输出内容删掉，例如调试信息等。
**************************************************************************/
